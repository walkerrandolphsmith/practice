# Stateful Workloads

So far we've added workloads to Kubernetes that can be replicated and scaled. Multiple instances of our HTTP server are seemingly identical. Kubernetes has handled load balancing the traffic across the instances and exposing only one endpoint for a consumer. Therefore as a consumer it didn't matter if there were 2 instances or 12 instances running. Services that do not maintain state can scale such that all instances can be treated interchangably, crashed instances can be replaced, and start up and shut down order doesn't matter. Stateful services on the other hand don't share these characteristics.

Consider a HTTP service that keeps track of user sessions in memory. If the user's first request was made against an instance then subsequent requests would need to continue to be made against that instance since in memory sessions are not shared across instances. This is refered to as a "sticky" session. This stateful service would need its own identity so future requests from our user get routed to the correct instance. The epitome of stateful service is the database or clustered applications like Kafka that require quorum.

StatefulSet is a Kubernetes object that handles special requirements for dedicated storage, unique identity, and specific start up and shut down routines. We'll discuss a few different types of stateful applications and consider how Kubernetes handles each case using StatefulSets.

## Dedicated Storage Requirements

Let's take our legacy application from lesson 17. It logged messages to disk at `/var/log/`. This was a contrived application, but we can use it to demonstrate the need for each instance to need its own log of events. Instead of using the Deployment object we'll use the StatefulSet object. StatefulSets also allow specifiying a number of replicas, but now the associated pods will have names with ordinals 0, 1, 2, etc instead of random hashes. Every pod generated from the StatefulSet will include a label, `statefulset.kubernetes.io/pod-name`.

The service object has been used as a single point of contact for all instances of a our application. We will have to leverage a service that exposes a single, specific instance, also known as a headless service. The headless service will not be given a clusterIP, but will get instance specific DNS records. Since every pod generated from the StatefulSet has a unique identity we can select it with the generated label and match our service with a specific instance. We can avoid the Service from proxying traffic to nodes that do not contain our selected pod by setting the `externalTrafficPolicy` to `Local`
